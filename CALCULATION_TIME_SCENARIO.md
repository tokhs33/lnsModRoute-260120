# 계산 소요 시간 분석: 차량 8대, 기존 OD 10건, 신규 OD 2건

## 시나리오 설정

| 항목 | 개수 | 비고 |
|-----|------|------|
| 차량 (vehicleLocs) | 8대 | - |
| 기존 배차 요청 OD | 10건 | onboard_waiting_demands로 가정 |
| 신규 배차 요청 | 2건 | new_demands |

---

## 1. 노드 수 계산

### 1.1 기본 계산식
```
nodeCount = vehicleCount + onboardDemands + 2 × (onboardWaitingDemands + newDemands)
```

### 1.2 시나리오별 노드 수

#### 시나리오 A: 기존 10건이 모두 onboard_waiting (일반적 케이스)
```
nodeCount = 8 + 0 + 2 × (10 + 2)
          = 8 + 0 + 2 × 12
          = 8 + 24
          = 32
```

#### 시나리오 B: 기존 10건 중 5건 탑승 완료, 5건 대기
```
nodeCount = 8 + 5 + 2 × (5 + 2)
          = 8 + 5 + 2 × 7
          = 8 + 5 + 14
          = 27
```

#### 시나리오 C: 기존 10건이 모두 탑승 완료 (드문 케이스)
```
nodeCount = 8 + 10 + 2 × (0 + 2)
          = 8 + 10 + 4
          = 22
```

**본 분석은 가장 일반적인 시나리오 A (nodeCount = 32)를 기준으로 합니다.**

---

## 2. 매트릭스 크기 계산

### 2.1 매트릭스 차원
```
매트릭스 크기 = (nodeCount + 1) × (nodeCount + 1)
             = (32 + 1) × (32 + 1)
             = 33 × 33
             = 1,089 개 거리/시간 계산
```

### 2.2 API 호출 횟수

#### OSRM의 경우
```
OSRM_MAX_LOCATIONS = 100

총 노드 수 = 32 < 100
→ 단일 API 호출로 처리 가능
→ API 호출 횟수 = 1회
```

#### Valhalla의 경우
```
VALHALLA_MAX_LOCATIONS = 50

총 노드 수 = 32 < 50
→ 단일 API 호출로 처리 가능
→ API 호출 횟수 = 1회
```

---

## 3. 계산 소요 시간 분석

### 3.1 현재 시스템 (필터링 없음)

#### 3.1.1 이론적 추정

기존 분석 데이터 기반 보간:

| 참고 데이터 | nodeCount | 매트릭스 크기 | 소요 시간 |
|----------|-----------|------------|---------|
| 데이터 1 | 25 | 676 | 450-600ms |
| **목표** | **32** | **1,089** | **?** |
| 데이터 2 | 50 | 2,601 | 900-1,300ms |

**보간 계산:**
```
시간 복잡도 ≈ O(n²)

비율 = (32² - 25²) / (50² - 25²)
     = (1,024 - 625) / (2,500 - 625)
     = 399 / 1,875
     = 0.213

예상 시간 = 450 + (900 - 450) × 0.213
         = 450 + 450 × 0.213
         = 450 + 96
         ≈ 546ms (하한)

또는
예상 시간 = 600 + (1,300 - 600) × 0.213
         = 600 + 700 × 0.213
         = 600 + 149
         ≈ 749ms (상한)
```

**결론: 550-750ms 예상**

#### 3.1.2 세부 시간 분해

| 단계 | 소요 시간 | 비율 | 설명 |
|-----|---------|------|------|
| **1. 매트릭스 계산** | **500-700ms** | **75-85%** | queryCostMatrix |
| ├─ OSRM/Valhalla API 호출 | 400-600ms | 60-75% | 네트워크 + 서버 처리 |
| ├─ 응답 파싱 | 50-80ms | 7-10% | JSON 파싱 |
| └─ 매트릭스 변환 | 30-50ms | 5-7% | 데이터 구조 변환 |
| **2. ALNS 최적화** | **150-300ms** | **15-25%** | solve_lns_pdptw |
| ├─ 초기해 생성 | 20-40ms | 3-5% | greedy construction |
| ├─ ALNS 반복 (iterations) | 100-230ms | 10-18% | destroy-repair |
| └─ 결과 변환 | 10-20ms | 2-3% | Solution → ModRoute |
| **전체 소요 시간** | **650-1,000ms** | **100%** | - |

#### 3.1.3 캐시 효과

**Cold Start (첫 요청)**
```
캐시 히트율 = 0%
소요 시간 = 650-1,000ms
```

**Warm Start (정류장 재사용)**
```
캐시 히트율 = 70-90% (Station Cache)
매트릭스 계산 시간 = 500ms × (1 - 0.8) = 100ms
전체 소요 시간 = 100 + 200 = 300ms
```

**Hot Start (동일 요청)**
```
캐시 히트율 = 100% (In-Memory Cache)
매트릭스 계산 시간 = 1ms
전체 소요 시간 = 1 + 200 = 201ms
```

---

## 4. 필터링 적용 시 예상 개선

### 4.1 직선거리 필터링 (10km 이내)

#### 필터링 효과 분석
```
신규 OD 2건에 대해:

[현재]
- 후보 차량: 8대 전체
- 계산 조합: 8 × 2 × 2 (P+D) = 32개

[필터링 후]
- 평균 후보 차량: 3-4대 (10km 이내)
- 계산 조합: 3.5 × 2 × 2 = 14개
- 감소율: (32 - 14) / 32 = 56%
```

#### 노드 수 재계산
```
기존 노드:
- 차량 8대: 8개
- 기존 OD 10건: 20개 (고정)

신규 OD 필터링:
- OD 1: 차량 3대 후보 → 2개 노드 (P+D)
- OD 2: 차량 4대 후보 → 2개 노드 (P+D)

실제로는 필터링된 차량만 매트릭스에 포함하므로:
유효 nodeCount ≈ 8 + 20 + 4 = 32 (동일)

하지만 실제 계산은 필요한 조합만:
- 차량 → 기존 OD: 8 × 10 = 80개
- 차량 → 신규 OD (필터링): 3.5 × 2 × 2 = 14개
- 기존 OD ↔ 기존 OD: 10 × 10 = 100개
- 기존 OD → 신규 OD: 10 × 2 × 2 = 40개
- 신규 OD ↔ 신규 OD: 2 × 2 × 2 = 8개

전체: 242개 (vs 현재 1,089개)
감소율: 78%
```

#### 예상 개선 시간
```
매트릭스 계산: 500ms × 0.22 = 110ms (78% 감소)
ALNS 최적화: 200ms (변동 없음)
전체 소요 시간: 110 + 200 = 310ms

개선율: (650 - 310) / 650 = 52%
```

### 4.2 용량 필터링 추가

#### 추가 효과
```
차량 8대 중:
- 용량 포화 차량: 2-3대 (기존 OD로 가득)
- 유효 후보: 5-6대

직선거리 필터링 후 3.5대 → 용량 필터링 후 2.5대
추가 감소: 28%

전체 감소율: 78% + (22% × 0.28) = 84%
```

#### 최종 예상 시간
```
매트릭스 계산: 500ms × 0.16 = 80ms
ALNS 최적화: 200ms
전체 소요 시간: 80 + 200 = 280ms

개선율: (650 - 280) / 650 = 57%
```

---

## 5. 시나리오별 종합 비교

| 시나리오 | 매트릭스 계산 | ALNS 최적화 | 전체 시간 | 비고 |
|---------|-----------|----------|---------|------|
| **현재 (Cold Start)** | 500-700ms | 150-300ms | **650-1,000ms** | 첫 요청 |
| **현재 (Warm Start)** | 100-150ms | 150-300ms | **250-450ms** | Station Cache 70-90% |
| **현재 (Hot Start)** | 1-5ms | 150-300ms | **150-305ms** | In-Memory Cache 100% |
| **거리 필터링 적용** | 100-150ms | 150-300ms | **250-450ms** | 52% 개선 |
| **거리+용량 필터링** | 70-110ms | 150-300ms | **220-410ms** | 57% 개선 |

---

## 6. 실시간 성능 벤치마크

### 6.1 측정 조건
```
환경:
- CPU: 4 Core / 8 Thread
- 메모리: 8GB
- 네트워크: 로컬 OSRM 서버
- 동시 요청: 1건 (순차 처리)
```

### 6.2 예상 결과

#### Cold Start (첫 요청)
```json
{
  "totalTime": "750ms",
  "breakdown": {
    "queryCostMatrix": "550ms",
    "solve_lns_pdptw": "180ms",
    "convertToResponse": "20ms"
  },
  "details": {
    "osrmApiCall": "450ms",
    "jsonParsing": "60ms",
    "matrixConversion": "40ms",
    "alnsIterations": 10000,
    "alnsTime": "180ms"
  }
}
```

#### Warm Start (정류장 70% 재사용)
```json
{
  "totalTime": "320ms",
  "breakdown": {
    "queryCostMatrix": "120ms (캐시 히트)",
    "solve_lns_pdptw": "180ms",
    "convertToResponse": "20ms"
  },
  "cacheHitRate": "0.72",
  "cacheType": "Station Cache"
}
```

#### Hot Start (동일 요청)
```json
{
  "totalTime": "200ms",
  "breakdown": {
    "queryCostMatrix": "2ms (전체 캐시)",
    "solve_lns_pdptw": "178ms",
    "convertToResponse": "20ms"
  },
  "cacheHitRate": "1.0",
  "cacheType": "In-Memory Cache"
}
```

---

## 7. 부하 테스트 시나리오

### 7.1 순차 처리 (현재 시스템)

```
요청 간격: 1초
처리율: 60 요청/분

시간대별 처리:
00:00 - 요청 1 시작
00:00.75 - 요청 1 완료
01:00 - 요청 2 시작
01:00.75 - 요청 2 완료
...
```

**처리 용량:**
- 평균 응답 시간: 750ms
- 최대 처리량: 80 요청/분 (이론상)
- 실제 처리량: 60 요청/분 (여유 포함)

### 7.2 동시 처리 (병렬 처리)

```
동시 요청 수: 4개
처리율: 240 요청/분 (4배 향상)

단, 리소스 경쟁으로 인한 지연:
- CPU 경쟁: +10-20%
- 메모리 경쟁: +5-10%
- 네트워크 경쟁 (OSRM): +20-30%

실제 처리율: 180-200 요청/분
```

---

## 8. 최적화 로드맵

### 8.1 Phase 1: 직선거리 필터링 (즉시)

**구현:**
```cpp
// 신규 OD마다 10km 이내 차량만 선택
std::vector<int> candidateVehicles;
for (auto& newDemand : newDemands) {
    for (int i = 0; i < vehicles.size(); i++) {
        double dist = haversineDistance(vehicles[i].location, newDemand.startLoc);
        if (dist <= 10.0) {  // 10km
            candidateVehicles.push_back(i);
        }
    }
}
```

**효과:**
- 계산 시간: 750ms → 350ms (53% 개선)
- 구현 시간: 1-2일

### 8.2 Phase 2: 용량 필터링 (1주)

**구현:**
```cpp
// 용량 초과 차량 제외
std::map<std::string, int> currentLoad;
for (auto& waiting : onboardWaitingDemands) {
    currentLoad[waiting.supplyIdx] += waiting.demand;
}

std::vector<int> validVehicles;
for (int idx : candidateVehicles) {
    int available = vehicles[idx].capacity - currentLoad[vehicles[idx].supplyIdx];
    if (available >= newDemand.demand) {
        validVehicles.push_back(idx);
    }
}
```

**효과:**
- 계산 시간: 350ms → 280ms (추가 20% 개선)
- 구현 시간: 3-5일

### 8.3 Phase 3: Adaptive 필터링 (1개월)

**전략:**
```cpp
double getMaxDistance(int odCount) {
    if (odCount <= 5) return 15.0;      // 느슨한 필터링
    else if (odCount <= 15) return 10.0; // 중간 필터링
    else return 5.0;                     // 강력한 필터링
}
```

**효과:**
- OD 개수에 따라 동적 조정
- 품질 vs 속도 최적 균형

---

## 9. 결론

### 9.1 질문에 대한 답변

**Q: 차량 8대, 기존 OD 10건, 신규 OD 2건 시 계산 소요 시간은?**

**A: 650-1,000ms (평균 750ms)**

| 상황 | 소요 시간 | 비고 |
|-----|---------|------|
| **Cold Start** | **650-1,000ms** | 첫 요청 |
| **Warm Start** | **250-450ms** | 캐시 70-90% 활용 |
| **Hot Start** | **150-305ms** | 캐시 100% 활용 |

### 9.2 세부 분해

```
총 650-1,000ms 중:

[매트릭스 계산] 500-700ms (75-85%)
  ├─ OSRM API: 400-600ms
  ├─ 파싱: 50-80ms
  └─ 변환: 30-50ms

[ALNS 최적화] 150-300ms (15-25%)
  ├─ 초기해: 20-40ms
  ├─ 반복: 100-230ms
  └─ 변환: 10-20ms
```

### 9.3 최적화 효과 비교

| 방법 | 소요 시간 | 개선율 |
|-----|---------|--------|
| 현재 시스템 | 750ms | - |
| 거리 필터링 | 350ms | 53% ↓ |
| 거리+용량 필터링 | 280ms | 63% ↓ |
| 캐시 활용 (Warm) | 350ms | 53% ↓ |
| 캐시 활용 (Hot) | 200ms | 73% ↓ |

### 9.4 권장사항

1. **즉시 구현**: 직선거리 필터링 (10km)
   - 효과: 750ms → 350ms
   - 구현 난이도: 낮음

2. **중기 구현**: 용량 필터링
   - 효과: 추가 70ms 절감
   - 구현 난이도: 중간

3. **캐시 활용 극대화**: Station ID 적극 사용
   - 효과: 750ms → 350ms
   - 구현 난이도: 없음 (기존 기능)

---

**분석 일자**: 2026-01-21
**시나리오**: 차량 8대, 기존 OD 10건, 신규 OD 2건
**nodeCount**: 32
**매트릭스 크기**: 33 × 33 = 1,089
**예상 소요 시간**: **650-1,000ms (평균 750ms)**
